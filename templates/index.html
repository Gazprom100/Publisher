    <!-- Scripts -->
    <script src="https://cdn.plot.ly/plotly-2.30.1.min.js"></script>
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    <script>
    document.addEventListener('DOMContentLoaded', function() {
        let reconnectAttempts = 0;
        const MAX_RECONNECT_ATTEMPTS = 5;
        let pingInterval;
        let socket;

        function initializeSocket() {
            // Инициализация Socket.IO с обработкой ошибок
            socket = io({
                path: '/socket.io',
                transports: ['websocket', 'polling'],
                upgrade: true,
                rememberUpgrade: true,
                timeout: 60000,  // Увеличено до 60 секунд
                reconnection: true,
                reconnectionAttempts: MAX_RECONNECT_ATTEMPTS,
                reconnectionDelay: 1000,
                reconnectionDelayMax: 5000,
                autoConnect: true,
                forceNew: true,
                pingTimeout: 60000,  // Увеличено до 60 секунд
                pingInterval: 25000,  // Увеличено до 25 секунд
                query: {
                    timestamp: Date.now()  // Предотвращаем кэширование
                }
            });

            // Обработчики событий Socket.IO
            socket.on('connect', () => {
                console.log('Connected to server');
                reconnectAttempts = 0;
                updateConnectionStatus('connected');
                startPingInterval();
                
                // Запрашиваем начальные данные
                updateAnalytics();
                updateChannelHealth();
                updateSchedule();
            });

            socket.on('disconnect', (reason) => {
                console.log('Disconnected from server:', reason);
                updateConnectionStatus('disconnected');
                stopPingInterval();

                if (reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
                    reconnectAttempts++;
                    console.log(`Attempting to reconnect (${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS})`);
                    setTimeout(() => {
                        socket.connect();
                    }, 1000 * Math.min(reconnectAttempts * 2, 10));  // Экспоненциальная задержка
                } else {
                    showError('Превышено максимальное количество попыток переподключения. Обновите страницу.');
                }
            });

            socket.on('connect_error', (error) => {
                console.error('Connection error:', error);
                updateConnectionStatus('error', error.message);
                stopPingInterval();

                // Попытка переключения на polling при ошибке websocket
                if (socket.io.engine.transport.name === 'websocket') {
                    console.log('WebSocket connection failed, falling back to polling');
                    socket.io.engine.transport.name = 'polling';
                    socket.connect();
                }
            });

            socket.on('error', (error) => {
                console.error('Socket error:', error);
                updateConnectionStatus('error', error.message);
            });

            socket.on('pong', (data) => {
                console.log('Received pong:', data);
                updateConnectionStatus('connected');
            });

            socket.on('connection_established', (data) => {
                console.log('Connection established:', data);
                updateConnectionStatus('connected');
                // Запрашиваем начальные данные
                updateAnalytics();
                updateChannelHealth();
                updateSchedule();
            });

            // Добавляем обработчик для отслеживания состояния подключения
            socket.io.on("reconnect_attempt", (attempt) => {
                console.log(`Reconnection attempt ${attempt}`);
                updateConnectionStatus('reconnecting');
            });

            socket.io.on("reconnect_failed", () => {
                console.log('Reconnection failed');
                updateConnectionStatus('error', 'Не удалось восстановить подключение');
                showError('Не удалось восстановить подключение к серверу. Пожалуйста, обновите страницу.');
            });
        }

        function startPingInterval() {
            stopPingInterval(); // Очищаем предыдущий интервал, если он существует
            pingInterval = setInterval(() => {
                if (socket && socket.connected) {
                    socket.emit('ping');
                }
            }, 25000);  // Увеличено до 25 секунд
        }

        function stopPingInterval() {
            if (pingInterval) {
                clearInterval(pingInterval);
                pingInterval = null;
            }
        }

        // Инициализация всех компонентов
        const refreshButton = document.getElementById('refreshData');
        if (refreshButton) {
            refreshButton.addEventListener('click', function() {
                if (socket && socket.connected) {
                    updateAnalytics();
                    updateChannelHealth();
                    updateSchedule();
                } else {
                    showError('Нет подключения к серверу');
                    if (socket) {
                        socket.connect();
                    } else {
                        initializeSocket();
                    }
                }
            });
        }

        // Функция обновления статуса соединения
        function updateConnectionStatus(status, message = '') {
            const statusElement = document.getElementById('connection-status');
            if (!statusElement) {
                const statusContainer = document.createElement('div');
                statusContainer.id = 'connection-status-container';
                statusContainer.className = 'position-fixed bottom-0 end-0 p-3';
                statusContainer.style.zIndex = '1000';
                
                const statusBadge = document.createElement('div');
                statusBadge.id = 'connection-status';
                statusBadge.className = 'badge';
                
                statusContainer.appendChild(statusBadge);
                document.body.appendChild(statusContainer);
            }

            const element = document.getElementById('connection-status');
            if (!element) return;

            element.className = 'badge';
            switch (status) {
                case 'connected':
                    element.textContent = 'Подключено';
                    element.classList.add('bg-success');
                    break;
                case 'disconnected':
                    element.textContent = 'Отключено';
                    element.classList.add('bg-danger');
                    break;
                case 'error':
                    element.textContent = `Ошибка: ${message}`;
                    element.classList.add('bg-danger');
                    break;
            }
        }

        // Функция отображения ошибок
        function showError(message) {
            const errorContainer = document.getElementById('error-container');
            if (!errorContainer) {
                const container = document.createElement('div');
                container.id = 'error-container';
                container.className = 'alert alert-danger alert-dismissible fade show';
                container.style.position = 'fixed';
                container.style.top = '20px';
                container.style.right = '20px';
                container.style.zIndex = '9999';
                document.body.appendChild(container);
            }
            
            errorContainer.innerHTML = `
                ${message}
                <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
            `;
            
            // Автоматически скрываем ошибку через 5 секунд
            setTimeout(() => {
                const alert = bootstrap.Alert.getOrCreateInstance(errorContainer);
                alert.close();
            }, 5000);
        }

        // Автоматическое обновление данных
        setInterval(() => {
            if (socket && socket.connected) {
                updateAnalytics();
                updateChannelHealth();
                updateSchedule();
            }
        }, 300000); // Каждые 5 минут

        // Запускаем инициализацию Socket.IO
        initializeSocket();
    });

    // Функция обновления аналитики
    function updateAnalytics() {
        fetch('/api/analytics')
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    // Обновление статистики
                    const elements = {
                        'total-posts': data.total_posts,
                        'posts-today': data.posts_today,
                        'active-channels': data.active_channels,
                        'total-reach': data.total_reach
                    };

                    // Безопасное обновление элементов
                    Object.entries(elements).forEach(([id, value]) => {
                        const element = document.getElementById(id);
                        if (element) {
                            element.textContent = value;
                        }
                    });

                    // Обновление графиков только если элементы существуют
                    const activityChart = document.getElementById('activity-chart');
                    if (activityChart) {
                        const activityTrace = {
                            x: Object.keys(data.activity_by_hour),
                            y: Object.values(data.activity_by_hour),
                            type: 'bar',
                            marker: {
                                color: '#2196F3'
                            }
                        };

                        const activityLayout = {
                            title: 'Активность по часам',
                            paper_bgcolor: 'rgba(0,0,0,0)',
                            plot_bgcolor: 'rgba(0,0,0,0)',
                            font: {
                                color: document.body.classList.contains('dark-theme') ? '#ffffff' : '#000000'
                            },
                            margin: { t: 30, r: 30, b: 40, l: 40 }
                        };

                        Plotly.newPlot('activity-chart', [activityTrace], activityLayout);
                    }

                    const contentTypeChart = document.getElementById('content-type-chart');
                    if (contentTypeChart) {
                        const contentTypeTrace = {
                            values: [data.posts_with_photo, data.posts_without_photo],
                            labels: ['С фото', 'Без фото'],
                            type: 'pie',
                            marker: {
                                colors: ['#2196F3', '#FFC107']
                            }
                        };

                        const contentTypeLayout = {
                            title: 'Типы контента',
                            paper_bgcolor: 'rgba(0,0,0,0)',
                            plot_bgcolor: 'rgba(0,0,0,0)',
                            font: {
                                color: document.body.classList.contains('dark-theme') ? '#ffffff' : '#000000'
                            },
                            margin: { t: 30, r: 30, b: 30, l: 30 }
                        };

                        Plotly.newPlot('content-type-chart', [contentTypeTrace], contentTypeLayout);
                    }
                }
            })
            .catch(error => console.error('Ошибка при обновлении аналитики:', error));
    }

    // Функция обновления дашборда
    function updateDashboard(posts) {
        if (!posts) return;
        
        try {
            // Обновляем статистику
            const stats = calculateStats(posts);
            updateStats(stats);
            
            // Обновляем графики
            updateCharts(stats);
            
            // Обновляем список постов
            updatePostsList(posts);
        } catch (error) {
            console.error('Error updating dashboard:', error);
        }
    }

    // Вспомогательные функции
    function calculateStats(posts) {
        const now = new Date();
        const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
        
        return {
            total: posts.length,
            today: posts.filter(post => new Date(post.time) >= today).length,
            withPhoto: posts.filter(post => post.photo).length,
            withoutPhoto: posts.filter(post => !post.photo).length,
            scheduled: posts.filter(post => post.state === 'ожидает').length
        };
    }

    function updateStats(stats) {
        const elements = {
            'total-posts': stats.total,
            'posts-today': stats.today,
            'posts-scheduled': stats.scheduled
        };

        Object.entries(elements).forEach(([id, value]) => {
            const element = document.getElementById(id);
            if (element) {
                element.textContent = value;
            }
        });
    }

    function updateCharts(stats) {
        // Обновление графика типов контента
        const contentTypeData = {
            values: [stats.withPhoto, stats.withoutPhoto],
            labels: ['С фото', 'Без фото'],
            type: 'pie'
        };

        const contentTypeLayout = {
            title: 'Типы контента',
            height: 300,
            margin: { t: 30, b: 30, l: 30, r: 30 }
        };

        const contentTypeChart = document.getElementById('content-type-chart');
        if (contentTypeChart) {
            Plotly.newPlot('content-type-chart', [contentTypeData], contentTypeLayout);
        }
    }

    function updatePostsList(posts) {
        const container = document.getElementById('posts-list');
        if (!container) return;

        // Сортируем посты по времени
        const sortedPosts = [...posts].sort((a, b) => 
            new Date(b.time) - new Date(a.time)
        );

        // Обновляем список
        container.innerHTML = sortedPosts.slice(0, 10).map(post => `
            <div class="post-item mb-3">
                <div class="d-flex justify-content-between">
                    <small>${new Date(post.time).toLocaleString()}</small>
                    <span class="badge ${post.state === 'выложен' ? 'bg-success' : 'bg-warning'}">
                        ${post.state}
                    </span>
                </div>
                <p class="mb-1">${post.text.substring(0, 100)}${post.text.length > 100 ? '...' : ''}</p>
                ${post.photo ? `<img src="${post.photo}" class="img-thumbnail" style="max-width: 100px;">` : ''}
            </div>
        `).join('');
    }
    </script> 